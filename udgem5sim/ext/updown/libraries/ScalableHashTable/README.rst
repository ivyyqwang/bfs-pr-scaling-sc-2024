=========================
Scalable Hash Table (SHT)
=========================

High Level Design
=================

The Scalable Hash Table (SHT) is a hash table design to run on UpDown system with linear performance scaling.
The SHT consists of many buckets, with only one UpDown lane operating on a bucket at a time. The bucket is implemented using an array.
Operations sent to the SHT first hashes the input key to a destination bucket, and the lane operating the bucket performs the specified operation.

APIs
====

Single-word value SHT
---------------------

``initialize``
^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t NWID, uint64_t NWID) initialize(
        uint64_t SHT_DESC_LM_OFFSET, uint64_t TMP_BUF_LM_OFFSET,
        uint64_t START_NWID, uint64_t NUM_ALLOC_LANES, 
        uint64_t BUCKET_DESC_LM_OFFSET, uint64_t DRAM_ALLOC_ADDR,
        uint64_t BUCKETS_PER_LANE, uint64_t ENTRIES_PER_BUCKET,
        );

* Description
    * initialize SHT & initialize all SHT buckets
* Operands
    #. ``X8``  - ``SHT_DESC_LM_OFFSET`` - SHT descriptor LM offset
    #. ``X9``  - ``TMP_BUF_LM_OFFSET`` - Temp LM send buffer offset for sending messages (8 words)
    #. ``X10`` - ``START_NWID`` - start NWID of the assigned lanes
    #. ``X11`` - ``NUM_ALLOC_LANES`` - number of assigned lanes
    #. ``X12`` - ``BUCKET_DESC_LM_OFFSET`` - (on each assigned UpDown lane) start LM offset for storing the SHT bucket descriptor
    #. ``X13`` - ``DRAM_ALLOC_ADDR`` - start DRAM address for the SHT. The required memory to be allocated at this address is computed as follows: `(sizeof(Key) + sizeof(value)) * BUCKETS_PER_LANE * ENTRIES_PER_BUCKET * NUM_ALLOC_LANES`
    #. ``X14`` - ``BUCKETS_PER_LANE`` - number of buckets per lane
    #. ``X15`` - ``ENTRIES_PER_BUCKET`` - number of entries per lane
* Returns
    #. ``X8`` - current network_id
    #. ``X9`` - current network_id

``update``
^^^^^^^^^^

.. code-block:: c++

    (uint64_t STATUS, uint64_t ADDR) update(
        uint64_t SHT_DESC_LM_OFFSET, uint64_t TMP_BUF_LM_OFFSET,
        uint64_t KEY, uint64_t VALUE, 
        );

* Description
    * add new entry or update existed entry in the SHT
* Operands
    #. ``X8``  - ``SHT_DESC_LM_OFFSET`` - SHT descriptor LM offset
    #. ``X9``  - ``TMP_BUF_LM_OFFSET`` - Temp LM buffer for sending messages
    #. ``X10`` - ``KEY`` - key to insert (1 word)
    #. ``X11`` - ``VALUE`` - value to insert (1 word)
* Returns
    #. ``X8`` - ``STATUS`` 1 for success, 0 for failure
    #. ``X9`` - ``ADDR`` if success, DRAM address for storing the *entry (key + value)*; if failure, current number of entries existed in the bucket

``get``
^^^^^^^

.. code-block:: c++

    (uint64_t STATUS, uint64_t VALUE) get(
        uint64_t SHT_DESC_LM_OFFSET, uint64_t TMP_BUF_LM_OFFSET,
        uint64_t KEY, uint64_t VALUE,
        );

* Description
    * get an existed entry in the SHT
*  Operands
    #. ``X8`` - ``SHT_DESC_LM_OFFSET`` - SHT descriptor LM offset
    #. ``X9`` - ``KEY`` - key for lookup (1 word)
* Returns
    #. ``X8`` - ``STATUS`` 1 for success, 0 for failure
    #. ``X9`` - ``VALUE`` if success, value corresponding to the key; if failure, the input key

[WIP] ``delete``
^^^^^^^^^^^^^^^^^

``get_iterators``
^^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t NWID,
     uint64_t NWID)
    get_iterators(
        uint64_t SHT_DESC_LM_OFFSET,
        uint64_t ITER_DRAM_ADDR
    );

* Description
    * Get an array of iterators for the SHT Extended. One iterator per bucket, 2 words per iterators.
* Operands
    #. ``SHT_DESC_LM_OFFSET[0:63]``
        * SHT descriptor LM offset
    #. ``ITER_DRAM_ADDR`` - DRAM address for storing the iterators; One iterator per bucket, 2 words per iterators.
* Returns
    #. ``X8`` - ``NWID``
    #. ``X9`` - ``NWID``

``get_next``
^^^^^^^^^^^^

.. code-block:: c++

    (uint32_t BUCKET_DESC_LM_OFFSET, uint32_t NWID,
     uint64_t CUR_POSITION,
     uint64_t KEY, uint64_t VAL)
    get_next(
        uint32_t BUCKET_DESC_LM_OFFSET, uint32_t NWID,
        uint64_t CUR_POSITION,
    );

* Description
    * Get next entry from a SHT Extended bucket using iterator
* Operands (NOTE: these operands should be generated by ``get_iterators`` API, the operands are for one iterator)
    #. ``BUCKET_DESC_LM_OFFSET[0:31] | NWID[32:63]``
        * Bits ``[0:31]``, (on each assigned UpDown lane) start LM offset for storing the SHT bucket descriptor
        * Bits ``[32:63]``, network_id for the bucket being iterated
    #. ``CUR_POSITION``
        * current position in the bucket
* Returns:
    #. ``X8``- ``BUCKET_DESC_LM_OFFSET[0:31] | NWID [32:63]`` - for the next ``get_next`` call
    #. ``X9``- ``CUR_POSITION`` - for the next ``get_next`` call, set to -1 if reached end, set to -2 if passed end
    #. ``X10`` - ``KEY`` - omit if passed end
    #. ``X11`` - ``VAL`` - omit if passed end

``get_next_split``
^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint32_t BUCKET_DESC_LM_OFFSET, uint32_t NWID,
     uint64_t CUR_POSITION)

   ([optional] KEY,
    [optional] VAL)

    get_next_split(
        uint32_t BUCKET_DESC_LM_OFFSET, uint32_t NWID,
        uint64_t CUR_POSITION,
        uint64_t KEY_VAL_CONT
    );

* Description
    * Get next entry from a SHT Extended bucket using iterator. The key & value are returned in a separate continuation to increase concurrency.
* Operands (NOTE: these operands should be generated by ``get_iterators`` API, the operands are for one iterator)
    #. ``BUCKET_DESC_LM_OFFSET[0:31] | NWID[32:63]``
        * Bits ``[0:31]``, (on each assigned UpDown lane) start LM offset for storing the SHT bucket descriptor
        * Bits ``[32:63]``, network_id for the bucket being iterated
    #. ``CUR_POSITION``
        * current position in the bucket
    #. ``KEY_VAL_CONT``
        * Continuation for the key & value
* Returns (with default continuation, operands should be used for the next call):
    #. ``X8``- ``BUCKET_DESC_LM_OFFSET[0:31] | NWID[32:63]`` - for the next ``get_next_split`` call
    #. ``X9``- ``CUR_POSITION`` - for the next ``get_next_split`` call, set to -1 if reached end, set to -2 if passed end
* Returns (with ``KEY_VAL_CONT``): - omit if passed end
    #. ``X8`` - ``KEY`` - omit if passed end
    #. ``X9`` - ``VAL`` - omit if passed end


Multi-word value SHT (SHT Extended / SHTExt)
--------------------------------------------

``initialize``
^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t SHT_DESC_SIZE, uint64_t SHT_LANE_DESC_SIZE) initialize(
        uint32_t SHT_DESC_LM_OFFSET, uint32_t TMP_BUF_LM_OFFSET,
        uint32_t NUM_ALLOC_LANES, uint32_t START_NWID,
        uint32_t LANE_DESC_LM_OFFSET, uint32_t BUCKETS_PER_LANE,
        uint32_t ENTRIES_PER_BUCKET, uint32_t VAL_NUM_WORDS,
        uint64_t DRAM_ALLOC_ADDR
        );

* Description
    * Initialize the SHT Extended data structure
* Operand Words
    #. ``SHT_DESC_LM_OFFSET[0:31] | TMP_BUF_LM_OFFSET [32:63]``
        * Bits ``[0:31]``, SHT descriptor LM offset
        * Bits ``[32:63]``, 64 bytes temp LM send buffer offset for preparing messages
    #. ``NUM_ALLOC_LANES[0:31] | START_NWID[32:63]``
        * Bits ``[0:31]``, number of allocated lanes
        * Bits ``[32:63]``, start NWID of the allocated lanes (lanes are allocated consecutivly)
    #. ``LANE_DESC_LM_OFFSET[0:31] | BUCKETS_PER_LANE[32:63]``
        * Bits ``[0:31]``, (on each allocated UpDown lane) start LM offset for storing the SHT lane descriptor
        * Bits ``[32:63]``, number of buckets per lane
    #. ``ENTRIES_PER_BUCKET[0:31] | VAL_NUM_WORDS[32:63]``
        * Bits ``[0:31]``, number of entries per bucket
        * Bits ``[32:63]``, number of words for the value in each entry
    #. ``DRAM_ALLOC_ADDR``
        * start DRAM address for the SHT Extended. The required memory to be allocated at this address is computed as follows: `(sizeof(Key) + sizeof(word) * VAL_NUM_WORDS) * BUCKETS_PER_LANE * ENTRIES_PER_BUCKET * NUM_ALLOC_LANES`
* Return Words
    #. ``X8`` - ``SHT_DESC_SIZE``
    #. ``X9`` - ``SHT_LANE_DESC_SIZE``

``update``
^^^^^^^^^^

.. code-block:: c++

    (uint64_t KEY, uint64_t VAL_ADDR) update(
        uint32_t SHT_DESC_LM_OFFSET, uint32_t TMP_BUF_LM_OFFSET,
        uint64_t KEY,
        uint64_t VAL0,
        [optional] uint64_t VAL1,
        [optional] uint64_t VAL2,
        [optional] uint64_t VAL3,
        [optional] uint64_t VAL4,
        [optional] uint64_t VAL5,
        );

* Description
    * Insert / update an entry in the SHT Extended using mask
* Operand Words
    #. ``SHT_DESC_LM_OFFSET[0:31] | TMP_BUF_LM_OFFSET [32:63]``
        * Bits ``[0:31]``, SHT descriptor LM offset
        * Bits ``[32:63]``, 64 bytes temp LM send buffer offset for preparing messages
    #. ``KEY`` - key
    #. ``VAL0`` - value for updating the entry
    #. ``VAL1`` - (optional) value for updating the entry
    #. ``VAL2`` - (optional) value for updating the entry
    #. ``VAL3`` - (optional) value for updating the entry
    #. ``VAL4`` - (optional) value for updating the entry
    #. ``VAL5`` - (optional) value for updating the entry
* Return Words
    #. ``X8`` - ``VID``
    #. ``X9`` - ``VAL_ADDR`` - set to 0 if failed (bucket full)

``update_with_mask``
^^^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t KEY, uint64_t MASK) update_with_mask(
        uint32_t SHT_DESC_LM_OFFSET, uint32_t TMP_BUF_LM_OFFSET,
        uint64_t KEY,
        uint64_t MASK,
        uint64_t VAL0,
        [optional] uint64_t VAL1,
        [optional] uint64_t VAL2,
        [optional] uint64_t VAL3,
        [optional] uint64_t VAL4,
        );

* Description
    * Insert / update an entry in the SHT Extended using mask
* Operand Words
    #. ``SHT_DESC_LM_OFFSET[0:31] | TMP_BUF_LM_OFFSET [32:63]``
        * Bits ``[0:31]``, SHT descriptor LM offset
        * Bits ``[32:63]``, 64 bytes temp LM send buffer offset for preparing messages
    #. ``KEY`` - key
    #. ``MASK`` - up to 64 bits mask to select which word to update
    #. ``VAL0`` - value for updating the entry
    #. ``VAL1`` - (optional) value for updating the entry
    #. ``VAL2`` - (optional) value for updating the entry
    #. ``VAL3`` - (optional) value for updating the entry
    #. ``VAL4`` - (optional) value for updating the entry
* Return Words
    #. ``X8`` - ``VID``
    #. ``X9`` - ``MASK`` - set to 0 if failed

``update_with_offset``
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t KEY, uint64_t OFFSET) update_with_offset(
        uint32_t SHT_DESC_LM_OFFSET, uint32_t TMP_BUF_LM_OFFSET,
        uint64_t KEY,
        uint64_t OFFSET,
        uint64_t VAL0,
        [optional] uint64_t VAL1,
        [optional] uint64_t VAL2,
        [optional] uint64_t VAL3,
        [optional] uint64_t VAL4,
        );

* Description
    * Insert / update an entry in the SHT Extended using offset
* Operand Words
    #. ``SHT_DESC_LM_OFFSET[0:31] | TMP_BUF_LM_OFFSET [32:63]``
        * Bits ``[0:31]``, SHT descriptor LM offset
        * Bits ``[32:63]``, 64 bytes temp LM send buffer offset for preparing messages
    #. ``KEY`` - key
    #. ``OFFSET`` - word offset to the value
    #. ``VAL0`` - value for updating the attributes
    #. ``VAL1`` - (optional) value for updating the entry
    #. ``VAL2`` - (optional) value for updating the entry
    #. ``VAL3`` - (optional) value for updating the entry
    #. ``VAL4`` - (optional) value for updating the entry
* Return Words
    #. ``X8`` - ``KEY``
    #. ``X9`` - ``OFFSET`` - set to -1 if failed

``get``
^^^^^^^

.. code-block:: c++

    (uint64_t KEY,
     uint64_t VAL_ADDR,
     [optional] VAL0,
     [optional] VAL1,
     [optional] VAL2,
     [optional] VAL3,
     [optional] VAL4,
     [optional] VAL5)
    get(
        uint64_t SHT_DESC_LM_OFFSET,
        uint64_t KEY,
    );

* Description
    * Get entry from the SHT Extended using mask
* Operands
    #. ``SHT_DESC_LM_OFFSET[0:63]``
        * SHT descriptor LM offset
    #. ``KEY`` - key
* Returns
    #. ``X8``  - ``KEY``
    #. ``X9``  - ``VAL_ADDR`` - set to 0 if failed (not found)
    #. ``X10`` - ``VAL0`` - (optional) value word 0
    #. ``X11`` - ``VAL1`` - (optional) value word 1
    #. ``X12`` - ``VAL2`` - (optional) value word 2
    #. ``X13`` - ``VAL3`` - (optional) value word 3
    #. ``X14`` - ``VAL4`` - (optional) value word 4
    #. ``X15`` - ``VAL5`` - (optional) value word 5

``get_with_mask``
^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t KEY,
     uint64_t MASK,
     [optional] VAL0,
     [optional] VAL1,
     [optional] VAL2,
     [optional] VAL3,
     [optional] VAL4,
     [optional] VAL5)
    get_with_mask(
        uint64_t SHT_DESC_LM_OFFSET,
        uint64_t KEY,
        uint64_t MASK
    );

* Description
    * Get entry from the SHT Extended using mask
* Operands
    #. ``SHT_DESC_LM_OFFSET[0:63]``
        * SHT descriptor LM offset
    #. ``KEY`` - key
    #. ``MASK`` - up to 64 bits mask to select which word to get
* Returns
    #. ``X8``  - ``KEY``
    #. ``X9``  - ``MASK`` - set to 0 if failed
    #. ``X10`` - ``VAL0`` - (optional) value word 0
    #. ``X11`` - ``VAL1`` - (optional) value word 1
    #. ``X12`` - ``VAL2`` - (optional) value word 2
    #. ``X13`` - ``VAL3`` - (optional) value word 3
    #. ``X14`` - ``VAL4`` - (optional) value word 4
    #. ``X15`` - ``VAL5`` - (optional) value word 5

``get_with_offset``
^^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t KEY,
     uint64_t OFFSET,
     [optional] VAL0,
     [optional] VAL1,
     [optional] VAL2,
     [optional] VAL3,
     [optional] VAL4,
     [optional] VAL5)
    get_with_offset(
        uint64_t SHT_DESC_LM_OFFSET,
        uint64_t KEY,
        uint64_t OFFSET
    );

* Description
    * Get entry from the SHT Extended using offset
* Operands
    #. ``SHT_DESC_LM_OFFSET[0:63]``
        * SHT descriptor LM offset
    #. ``KEY`` - key
    #. ``OFFSET`` - word offset to the value
* Returns
    #. ``X8``  - ``KEY``
    #. ``X9``  - ``OFFSET`` - set to -1 if failed
    #. ``X10`` - ``VAL0`` - (optional) value word 0
    #. ``X11`` - ``VAL1`` - (optional) value word 1
    #. ``X12`` - ``VAL2`` - (optional) value word 2
    #. ``X13`` - ``VAL3`` - (optional) value word 3
    #. ``X14`` - ``VAL4`` - (optional) value word 4
    #. ``X15`` - ``VAL5`` - (optional) value word 5

[WIP] ``delete``
^^^^^^^^^^^^^^^^^

``get_iterators``
^^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint64_t NWID,
     uint64_t NWID)
    get_iterators(
        uint64_t SHT_DESC_LM_OFFSET,
        uint64_t ITER_DRAM_ADDR
    );

* Description
    * Get an array of iterators for the SHT Extended. One iterator per bucket, 2 words per iterators.
* Operands
    #. ``SHT_DESC_LM_OFFSET[0:63]``
        * SHT descriptor LM offset
    #. ``ITER_DRAM_ADDR`` - DRAM address for storing the iterators; One iterator per bucket, 2 words per iterators.
* Returns
    #. ``X8``  - ``NWID``
    #. ``X9``  - ``NWID``

``get_next``
^^^^^^^^^^^^

.. code-block:: c++

    (uint32_t LANE_DESC_LM_OFFSET, uint32_t BUCKET_DESC_LM_OFFSET,
     uint32_t NWID, uint32_t CUR_POSITION,
     uint64_t KEY, uint64_t VAL_ADDR)
    get_next(
        uint32_t LANE_DESC_LM_OFFSET, uint32_t BUCKET_DESC_LM_OFFSET,
        uint32_t NWID, uint32_t CUR_POSITION
    );

* Description
    * Get next entry from a SHT Extended bucket using iterator
* Operands (NOTE: these operands should be generated by ``get_iterators`` API, the operands are for one iterator)
    #. ``LANE_DESC_LM_OFFSET[0:31] | BUCKET_DESC_LM_OFFSET[32:63]``
        * Bits ``[0:31]``, (on each assigned UpDown lane) start LM offset for storing the SHT lane descriptor
        * Bits ``[32:63]``, (on each assigned UpDown lane) start LM offset for storing the SHT bucket descriptor
    #. ``NWID[0:31] | CUR_POSITION[32:63]``
        * Bits ``[0:31]``, network_id for the bucket being iterated
        * Bits ``[32:63]``, current position in the bucket
* Returns:
    #. ``X8``- ``LANE_DESC_LM_OFFSET[0:31] | BUCKET_DESC_LM_OFFSET[32:63]`` - for the next ``get_next`` call
    #. ``X9``- ``NWID[0:31] | CUR_POSITION[32:63]`` - for the next ``get_next`` call, ``CUR_POSITION[0:31]`` set to -1 if reached end, set to -2 if passed end
    #. ``X10`` - ``KEY`` - omit if passed end
    #. ``X11`` - ``VAL_ADDR`` - omit if passed end

``get_next_split``
^^^^^^^^^^^^^^^^^^

.. code-block:: c++

    (uint32_t LANE_DESC_LM_OFFSET, uint32_t BUCKET_DESC_LM_OFFSET,
     uint32_t NWID, uint32_t CUR_POSITION)

   ([optional] KEY,
    [optional] VAL_ADDR)

    get_next_split(
        uint32_t LANE_DESC_LM_OFFSET, uint32_t BUCKET_DESC_LM_OFFSET,
        uint32_t NWID, uint32_t CUR_POSITION
        uint64_t KEY_ADDR_CONT
    );

* Description
    * Get next entry from a SHT Extended bucket using iterator. The key & value address are returned in a separate continuation to increase concurrency.
* Operands (NOTE: these operands should be generated by ``get_iterators`` API, the operands are for one iterator)
    #. ``LANE_DESC_LM_OFFSET[0:31] | BUCKET_DESC_LM_OFFSET[32:63]``
        * Bits ``[0:31]``, (on each assigned UpDown lane) start LM offset for storing the SHT lane descriptor
        * Bits ``[32:63]``, (on each assigned UpDown lane) start LM offset for storing the SHT bucket descriptor
    #. ``NWID[0:31] | CUR_POSITION[32:63]``
        * Bits ``[0:31]``, network_id for the bucket being iterated
        * Bits ``[32:63]``, current position in the bucket
    #. ``KEY_ADDR_CONT``
        * Continuation for the key & value address
* Returns (with default continuation, operands should be used for the next call):
    #. ``X8``- ``LANE_DESC_LM_OFFSET[0:31] | BUCKET_DESC_LM_OFFSET[32:63]`` - for the next ``get_next_split`` call
    #. ``X9``- ``NWID[0:31] | CUR_POSITION[32:63]`` - for the next ``get_next_split`` call, ``CUR_POSITION[0:31]`` set to -1 if reached end, set to -2 if passed end
* Returns (with ``KEY_ADDR_CONT``): - omit if passed end
    #. ``X8`` - ``KEY`` - omit if passed end
    #. ``X9`` - ``VAL_ADDR`` - omit if passed end

Source Files
============

Single-word value SHT
---------------------

* ``sht.py``
    * SHT top layer, hash & distribute operations to a SHT bucket

* ``sht_bucket.py``
    * SHT bucket, container for the hash table entries

* ``sht_macros.py``
    * Macros for call/return, Multi-Reader-Single-Writer Lock, Spin Lock, etc.

* ``sht_call_macros.py``
    * Macros for helping making SHT calls if writing in assembly

* ``sht.udwh``
    * UDWeave header for making SHT calls if using UDWeave

Example Program
^^^^^^^^^^^^^^^

* ``apps/sht_tests/linkable/sht_example.cpp``
* ``apps/sht_tests/linkable/sht_example.py``
* ``apps/sht_tests/linkable/Makefile``

Multi-word value SHT (SHT Extended / SHTExt)
--------------------------------------------

* ``sht_ext.py``
    * Main SHT Extended source file, including top layer & container for each SHT Extended lane

* ``sht_macros.py``
    * Macros for call/return, Multi-Reader-Single-Writer Lock, Spin Lock, etc.

* ``memcpy.py``
    * Memcpy for copying value between DRAM locations, as well as between DRAM & LM

* ``sht_call_macros.py``
    * Macros for helping making SHT calls if writing in assembly

* ``sht_ext.udwh``
    * UDWeave header for making SHT calls if using UDWeave

Performance
===========

Single-word value SHT
---------------------

Strong scaling with 4096 updates (updating exiting entries) & 32768 gets (on the 4096 existed entries):
The buckets are pre-filled with 2 entries
4096 updates has been performed before the test

=====   ============   ==========   =======
LANES   BUCKETS/LANE   UPDATE/SEC   GET/SEC
=====   ============   ==========   =======
64      1              1.37 B       0.910 B
64      2              1.37 B       1.56 B 
64      4              1.37 B       2.05 B 
64      8              1.37 B       2.18 B 
64      16             1.37 B       2.18 B 
64      32             1.37 B       2.18 B 
64      64             1.37 B       2.18 B 
128     1              2.45 B       4.16 B 
128     2              2.34 B       4.44 B 
128     4              2.53 B       4.42 B 
128     8              2.51 B       4.48 B 
128     16             2.63 B       4.53 B 
128     32             2.54 B       4.55 B 
128     64             2.60 B       4.48 B 
256     1              4.14 B       8.79 B 
256     2              4.13 B       8.74 B 
256     4              4.38 B       8.75 B 
256     8              4.35 B       9.00 B 
256     16             3.32 B       8.79 B 
256     32             4.24 B       8.81 B 
256     64             4.16 B       8.79 B 
=====   ============   ==========   =======
